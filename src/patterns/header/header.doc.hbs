---
title: Header
---

<div class="row">
	<div class="col-md-8">
<p class="lead">The header pattern includes the University logo and search field. The header may also include audience-specific navigation links above the search bar.</p>

<h2>Rules for the header</h2>
<ul>
	<li>The header must be included at the top of all webpages.</li>
	<li>The University logo used for the header must be the "Founded in 1413" variant in black.</li>
	<li>The background colour of the header must always be white.</li>
</ul>

<h2>Options available</h2>
<ul>
{{#header-options.options}}
    <li><a href="#{{option-anchor}}">{{option-heading}}</a></li>
{{/header-options.options}}
{{{ rend 'patternTitle' }}}
</ul>
</div>
</div>
{{#header-options.options}}
<hr>
<div class="row">
	<div class="col-md-8">
<h3 id="{{option-anchor}}">{{option-heading}}</h3>
{{{option-description}}}
</div>
</div>
<!--noindex-->
	<span class="label label-default">Example</span>
</div>
<div>
 
	{{> example patternTitle='header' index=@index}}
</div>
<div class="container">
<span class="label label-default">Code</span>
{{#markdown}}
```html
{{> header}}
```
{{/markdown}}
<!--endnoindex-->
{{/header-options.options}}

<script>



// --------------------------
//
// --------------------------
const patternWrappers = document.getElementsByClassName('pattern-wrapper');   // get all Example wrappers
var newCSSRules = new Array();                                                // will hold the new classes
var patternWrappersChildIds = new Array(); 
var cssRules = new Array();
var  newAndOldIDs = new Array();
Array.from(patternWrappers).forEach((pattern) =>{
    // get all the elements that have ids
    patternWrappersChildIds = patternWrappersChildIds.concat(getElementIDS(pattern));
    // remove all the duplicate ids
    patternWrappersChildIds = [...new Set(patternWrappersChildIds)];

});



// loop over all attached stylesheets
Array.from(document.styleSheets).forEach((stylesheet) =>{
    // get any style that has a relevent id
    cssRules = cssRules.concat(getEffectedRules(stylesheet,patternWrappersChildIds ));
});

// remove all the duplicate sytles
allCSSRules = [...new Set(cssRules)];
// console.log(cssRules);
patternWrappersChildIds = [...new Set(patternWrappersChildIds)];
// build the new css rules replacing in ids 
 newCSSRules = createNewStyles(allCSSRules,patternWrappersChildIds );
 newCSSRules  = [...new Set( newCSSRules )];
attachStyles(newCSSRules);


// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// --------------------------------------------------------------------- 

 function attachStyles(e) { 
    const styleEl = document.createElement("style"); 
    document.head.appendChild(styleEl); 
    const styleSheet = styleEl.sheet;
    Array.from(e).forEach((rule) =>{
        console.log(rule);
     styleSheet.insertRule(rule);
    }); 
 }



function createNewStyles(allCSSRules,newAndOldIDs){
    var allCSSRulesText = [];
    var newCSSRules = new Array();
    Array.from(allCSSRules).forEach((rule,i,allCSSRules) =>{
        
        if(rule.parentRule){
            allCSSRulesText.push(rule.parentRule.cssText);
        }else{
            allCSSRulesText.push(rule.cssText);
        }
    });
  // console.log( allCSSRulesText);

    Array.from(newAndOldIDs).forEach((ids,i) =>{
        Array.from(allCSSRulesText).forEach((rule,j) =>{           
            if(rule.includes(ids['oldID'])){
                allCSSRulesText[j] = allCSSRulesText[j].replace(ids['oldID']+':before', ids['oldID']+':before, '+ids['newID']+':before').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replace(ids['oldID']+':after', ids['oldID']+':after, '+ids['newID']+':after').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replace(ids['oldID']+',', ids['oldID']+',', ', '+ids['newID']+',').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replace(ids['oldID']+' ', ids['oldID']+', '+ids['newID']+' ').toString();
            }
        });
    });

    Array.from(newAndOldIDs).forEach((ids,i) =>{
        Array.from(allCSSRulesText).forEach((rule,j) =>{           
            if(rule.includes(ids['oldID'])){
                allCSSRulesText[j] = allCSSRulesText[j].replaceAll(ids['oldID']+':', '').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replaceAll(ids['oldID']+',', '').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replaceAll(ids['oldID']+' ', '').toString();                   
             //   allCSSRulesText[j] = allCSSRulesText[j].replaceAll(' ', '').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replaceAll(',,', ',').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replaceAll(', ,', ', ').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replaceAll('{,', '{').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replaceAll('::', ':').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replaceAll('::', ':').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replaceAll(',:after', '').toString();
                allCSSRulesText[j] = allCSSRulesText[j].replaceAll(',:before', '').toString();
                if(allCSSRulesText[j].startsWith(",")){
                   allCSSRulesText[j] = allCSSRulesText[j].substring(1);
                }
     
            }
        });
    });
  return allCSSRulesText;

}



 // get all styles for the ids
function getEffectedRules(stylesheet,patternWrappersChildIds){
    var styles = new Array();
    if(stylesheet.cssRules && stylesheet.media ){
        Array.from(stylesheet.cssRules).forEach((rule) =>{
          if(rule.cssRules && rule.cssRules.length > 0){
              // has child rules, Likely a media query 
              styles =  styles.concat(getEffectedRules(rule,patternWrappersChildIds));
          }
          if( (!rule.media || !rule.media[0] =='print' ) && rule.cssText && rule.cssText.length > 0 &&  (patternWrappersChildIds.some(patternWrappersChildId => rule.cssText.includes(patternWrappersChildId.oldID)))){
            styles.push(rule);                
          }     
        });
    }
    return styles;
}

 // Recursively loop over all the child elements and get the ids
function getElementIDS(patternWrapper){
    let IDs = [];
    if(patternWrapper.id && !IDs.includes(patternWrapper.id)){
        var newID =  creatNewID();
        var sub = {
            'oldID':'#'+patternWrapper.id,
            'newID': '#'+newID
        }
        patternWrapper.id = newID;
        IDs.push(sub);
    }
    patternWrapper.childNodes.forEach((node) =>{
       IDs = IDs.concat(getElementIDS(node));
    });
    return IDs;
}

function creatNewID(){
    return "newid" + (Math.random() + 1).toString(36).substring(7);
}

	

/*
	if ( document.getElementById("header-logo"))
	{
		var e = document.getElementById("header-logo");
		e.id = "appheader";
		alert('bo');
	}
*/



</script>